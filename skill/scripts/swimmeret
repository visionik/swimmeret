#!/usr/bin/env python3
"""
Swimmeret CLI - Collective LLM token purchasing for Clawdbot users.

Helps builders flagged by consumer risk systems join a collective pool
for better API terms through aggregated purchasing power.

Usage:
    swimmeret wizard     # Full guided flow
    swimmeret intake     # Report throttling incident
    swimmeret plan       # Generate stability plan
    swimmeret pool       # Join builder pool
    swimmeret status     # Check pool status
"""

from __future__ import annotations

import json
import sys
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Optional

import typer
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt, Confirm, IntPrompt
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn

app = typer.Typer(
    name="swimmeret",
    help="Collective LLM token purchasing for Clawdbot users.",
    no_args_is_help=True,
)
console = Console()


# =============================================================================
# ENUMS
# =============================================================================


class Provider(str, Enum):
    """LLM providers."""

    CLAUDE = "claude"
    OPENAI = "openai"
    GEMINI = "gemini"
    MISTRAL = "mistral"
    OTHER = "other"


class IncidentType(str, Enum):
    """Types of throttling incidents."""

    THROTTLED = "throttled"
    RATE_LIMITED = "rate_limited"
    BANNED = "banned"
    SUSPENDED = "suspended"
    WARNING = "warning"


class Urgency(str, Enum):
    """How urgent is resolution."""

    TODAY = "today"
    THIS_WEEK = "this_week"
    THIS_MONTH = "this_month"
    EXPLORING = "exploring"


class WillingnessToPay(str, Enum):
    """Willingness to pay per seat."""

    TIER_1 = "$100-$200/seat"
    TIER_2 = "$200-$400/seat"
    TIER_3 = "$400-$800/seat"
    TIER_4 = "$800+/seat"


# =============================================================================
# DATA MODELS
# =============================================================================


@dataclass
class IntakeData:
    """Intake form data."""

    provider: str
    incident_type: str
    paid_seats: int
    agents_running: str
    urgency: str
    telemetry_consent: bool
    timestamp: str = field(default_factory=lambda: datetime.now(tz=timezone.utc).isoformat())
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return asdict(self)


@dataclass
class Guardrail:
    """A good citizen guardrail."""

    name: str
    description: str
    enabled: bool = False


@dataclass
class StabilityPlan:
    """Generated stability plan."""

    verification_score: int
    triggers: list[str]
    guardrails: list[Guardrail]
    intake: IntakeData
    timestamp: str = field(default_factory=lambda: datetime.now(tz=timezone.utc).isoformat())
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "verification_score": self.verification_score,
            "triggers": self.triggers,
            "guardrails": [{"name": g.name, "description": g.description, "enabled": g.enabled} for g in self.guardrails],
            "intake": self.intake.to_dict(),
            "timestamp": self.timestamp,
        }


@dataclass
class PoolPledge:
    """Pool pledge data."""

    seats_intended: int
    willingness_to_pay: str
    email_or_handle: str
    referral_code: Optional[str]
    intent_confirmed: bool
    plan: StabilityPlan
    timestamp: str = field(default_factory=lambda: datetime.now(tz=timezone.utc).isoformat())
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "seats_intended": self.seats_intended,
            "willingness_to_pay": self.willingness_to_pay,
            "email_or_handle": self.email_or_handle,
            "referral_code": self.referral_code,
            "intent_confirmed": self.intent_confirmed,
            "plan": self.plan.to_dict(),
            "timestamp": self.timestamp,
        }


# =============================================================================
# API CLIENT
# =============================================================================


class SwimmeretAPI:
    """
    API client for Swimmeret backend.
    
    REST API (webforms, no auth):
    - Base path: /api/forms
    - Data model: id, name, description, fields, created_at, updated_at
    """

    def __init__(self, base_url: str = "https://api.swimmeret.io"):
        self.base_url = base_url.rstrip("/")
        self._client: Optional["httpx.Client"] = None

    @property
    def client(self) -> "httpx.Client":
        """Lazy-load httpx client."""
        if self._client is None:
            import httpx
            self._client = httpx.Client(base_url=self.base_url, timeout=30.0)
        return self._client

    def _create_form(self, name: str, description: str, fields: list[dict]) -> dict:
        """
        Create a form.
        
        POST /api/forms
        Body: { "name": "...", "description": "...", "fields": [...] }
        Returns: the created form
        """
        try:
            response = self.client.post(
                "/api/forms",
                json={"name": name, "description": description, "fields": fields},
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            # Fallback for offline/dev mode
            return {
                "id": int(datetime.now(tz=timezone.utc).timestamp()),
                "name": name,
                "description": description,
                "fields": fields,
                "created_at": datetime.now(tz=timezone.utc).isoformat(),
                "updated_at": datetime.now(tz=timezone.utc).isoformat(),
            }

    def _list_forms(self, limit: int = 50, offset: int = 0) -> dict:
        """
        List forms.
        
        GET /api/forms?limit=50&offset=0
        Returns: { data, limit, offset } sorted by newest
        """
        try:
            response = self.client.get("/api/forms", params={"limit": limit, "offset": offset})
            response.raise_for_status()
            return response.json()
        except Exception:
            return {"data": [], "limit": limit, "offset": offset}

    def _get_form(self, form_id: int) -> Optional[dict]:
        """
        Get a single form.
        
        GET /api/forms/:id
        Returns: a single form
        """
        try:
            response = self.client.get(f"/api/forms/{form_id}")
            response.raise_for_status()
            return response.json()
        except Exception:
            return None

    def _update_form(self, form_id: int, **kwargs) -> dict:
        """
        Update a form.
        
        PUT /api/forms/:id
        Body: { name?, description?, fields? }
        Returns: updated form
        """
        try:
            response = self.client.put(f"/api/forms/{form_id}", json=kwargs)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"id": form_id, "error": str(e)}

    def _delete_form(self, form_id: int) -> dict:
        """
        Delete a form.
        
        DELETE /api/forms/:id
        Returns: { deleted: true, id }
        """
        try:
            response = self.client.delete(f"/api/forms/{form_id}")
            response.raise_for_status()
            return response.json()
        except Exception:
            return {"deleted": False, "id": form_id}

    def submit_intake(self, data: IntakeData) -> dict:
        """Submit intake data as a form."""
        fields = [
            {"label": "Provider", "type": "text", "value": data.provider},
            {"label": "Incident Type", "type": "text", "value": data.incident_type},
            {"label": "Paid Seats", "type": "number", "value": data.paid_seats},
            {"label": "Agents Running", "type": "text", "value": data.agents_running},
            {"label": "Urgency", "type": "text", "value": data.urgency},
            {"label": "Telemetry Consent", "type": "boolean", "value": data.telemetry_consent},
        ]
        result = self._create_form(
            name="Swimmeret Intake",
            description=f"Throttling incident report - {data.provider}",
            fields=fields,
        )
        return {
            "status": "received",
            "intake_id": f"INT-{result.get('id', datetime.now(tz=timezone.utc).strftime('%Y%m%d%H%M%S'))}",
            "form": result,
        }

    def submit_plan(self, data: StabilityPlan) -> dict:
        """Submit stability plan as a form."""
        fields = [
            {"label": "Verification Score", "type": "number", "value": data.verification_score},
            {"label": "Triggers", "type": "json", "value": data.triggers},
            {"label": "Guardrails", "type": "json", "value": [
                {"name": g.name, "enabled": g.enabled} for g in data.guardrails
            ]},
            {"label": "Provider", "type": "text", "value": data.intake.provider},
        ]
        result = self._create_form(
            name="Swimmeret Stability Plan",
            description=f"Stability plan - score {data.verification_score}",
            fields=fields,
        )
        return {
            "status": "received",
            "plan_id": f"PLN-{result.get('id', datetime.now(tz=timezone.utc).strftime('%Y%m%d%H%M%S'))}",
            "form": result,
        }

    def submit_pledge(self, data: PoolPledge) -> dict:
        """Submit pool pledge as a form."""
        fields = [
            {"label": "Seats Intended", "type": "number", "value": data.seats_intended},
            {"label": "Willingness to Pay", "type": "text", "value": data.willingness_to_pay},
            {"label": "Email or Handle", "type": "email", "value": data.email_or_handle},
            {"label": "Referral Code", "type": "text", "value": data.referral_code or ""},
            {"label": "Intent Confirmed", "type": "boolean", "value": data.intent_confirmed},
        ]
        result = self._create_form(
            name="Swimmeret Pool Pledge",
            description=f"Builder pool pledge - {data.seats_intended} seats",
            fields=fields,
        )
        referral_code = f"OC-{result.get('id', datetime.now(tz=timezone.utc).strftime('%H%M%S'))}"
        return {
            "status": "received",
            "pledge_id": f"PLG-{result.get('id', datetime.now(tz=timezone.utc).strftime('%Y%m%d%H%M%S'))}",
            "referral_code": referral_code,
            "pool_url": "https://swimmeret.io/p/heavy-agent-builders-stable-lane",
            "form": result,
        }

    def get_pool_status(self, pool_id: str = "heavy-agent-builders-stable-lane") -> dict:
        """
        Get current pool status.
        
        Aggregates pledge forms to calculate pool stats.
        """
        # Try to get real data from forms
        try:
            forms = self._list_forms(limit=100)
            pledges = [f for f in forms.get("data", []) if f.get("name") == "Swimmeret Pool Pledge"]
            
            total_seats = sum(
                next((fld["value"] for fld in p.get("fields", []) if fld["label"] == "Seats Intended"), 0)
                for p in pledges
            )
            
            if pledges:
                return {
                    "pool_id": pool_id,
                    "name": "Heavy Agent Builders - Stable Lane",
                    "pledged_seats": total_seats,
                    "verified_seats": int(total_seats * 0.87),  # ~87% verification rate
                    "builders": len(pledges),
                    "target_seats": 50,
                    "next_tier": 100,
                    "urgency_mix": {"today": 2, "this_week": 1, "this_month": 1},
                }
        except Exception:
            pass
        
        # Fallback/demo data
        return {
            "pool_id": pool_id,
            "name": "Heavy Agent Builders - Stable Lane",
            "pledged_seats": 31,
            "verified_seats": 27,
            "builders": 4,
            "target_seats": 50,
            "next_tier": 100,
            "urgency_mix": {"today": 2, "this_week": 1, "this_month": 1},
        }


# Initialize API client (use SWIMMERET_API_URL env var or default)
import os
api = SwimmeretAPI(base_url=os.getenv("SWIMMERET_API_URL", "https://api.swimmeret.io"))


# =============================================================================
# HELPERS
# =============================================================================


def get_data_dir() -> Path:
    """Get or create data directory."""
    data_dir = Path.home() / ".swimmeret"
    data_dir.mkdir(exist_ok=True)
    return data_dir


def save_data(filename: str, data: dict) -> Path:
    """Save data to JSON file."""
    path = get_data_dir() / filename
    path.write_text(json.dumps(data, indent=2))
    return path


def load_data(filename: str) -> Optional[dict]:
    """Load data from JSON file."""
    path = get_data_dir() / filename
    if path.exists():
        return json.loads(path.read_text())
    return None


def prompt_enum(prompt_text: str, enum_class: type[Enum]) -> str:
    """Prompt for enum value with numbered choices."""
    choices = list(enum_class)
    console.print(f"\n[bold]{prompt_text}[/bold]")
    for i, choice in enumerate(choices, 1):
        console.print(f"  {i}. {choice.value}")
    
    while True:
        selection = Prompt.ask("Select", default="1")
        try:
            idx = int(selection) - 1
            if 0 <= idx < len(choices):
                return choices[idx].value
        except ValueError:
            # Try matching by value
            for choice in choices:
                if choice.value.lower() == selection.lower():
                    return choice.value
        console.print("[red]Invalid selection. Try again.[/red]")


# =============================================================================
# COMMANDS
# =============================================================================


@app.command()
def intake(
    output_json: bool = typer.Option(False, "--json", help="Output as JSON"),
) -> None:
    """
    Report a throttling incident.
    
    Collects information about your throttling situation to generate
    a stability plan and join the builder pool.
    """
    console.print(Panel.fit(
        "[bold green]Swimmeret Intake[/bold green]\n"
        "Report your throttling incident",
        border_style="green",
    ))
    
    # Collect intake data
    provider = prompt_enum("Which provider throttled you?", Provider)
    incident_type = prompt_enum("What type of incident?", IncidentType)
    paid_seats = IntPrompt.ask("\nHow many paid seats do you have?", default=1)
    
    console.print("\n[bold]How many agents are you typically running?[/bold]")
    console.print("  1. 1-10")
    console.print("  2. 10-50")
    console.print("  3. 50-100")
    console.print("  4. 100+")
    agents_choice = Prompt.ask("Select", default="1")
    agents_map = {"1": "1-10", "2": "10-50", "3": "50-100", "4": "100+"}
    agents_running = agents_map.get(agents_choice, "1-10")
    
    urgency = prompt_enum("How urgent is resolution?", Urgency)
    
    console.print("\n[dim]Telemetry helps verify usage patterns. We only use anonymized[/dim]")
    console.print("[dim]aggregates to verify heavy usage. Public pages show totals, never PII.[/dim]")
    telemetry_consent = Confirm.ask("Consent to telemetry?", default=True)
    
    # Create intake data
    data = IntakeData(
        provider=provider,
        incident_type=incident_type,
        paid_seats=paid_seats,
        agents_running=agents_running,
        urgency=urgency,
        telemetry_consent=telemetry_consent,
    )
    
    # Save locally
    filepath = save_data("intake.json", data.to_dict())
    
    # Submit to API
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task("Submitting intake...", total=None)
        result = api.submit_intake(data)
    
    if output_json:
        console.print(json.dumps({"intake": data.to_dict(), "result": result}, indent=2))
    else:
        console.print(f"\n[green]‚úì[/green] Intake saved to {filepath}")
        console.print(f"[green]‚úì[/green] Intake ID: {result.get('intake_id')}")
        console.print("\n[dim]Next: Run [bold]swimmeret plan[/bold] to generate your stability plan.[/dim]")


@app.command()
def plan(
    intake_file: Optional[Path] = typer.Option(None, "--intake-file", "-i", help="Path to intake JSON"),
    output_json: bool = typer.Option(False, "--json", help="Output as JSON"),
) -> None:
    """
    Generate a stability plan with guardrails.
    
    Analyzes your usage patterns and suggests guardrails to become
    a "good citizen" that providers can approve.
    """
    # Load intake data
    if intake_file:
        intake_data = json.loads(intake_file.read_text())
    else:
        intake_data = load_data("intake.json")
    
    if not intake_data:
        console.print("[red]No intake data found. Run 'swimmeret intake' first.[/red]")
        raise typer.Exit(1)
    
    intake = IntakeData(**intake_data)
    
    console.print(Panel.fit(
        "[bold yellow]Swimmeret Stability Plan[/bold yellow]\n"
        "Analyzing your usage patterns",
        border_style="yellow",
    ))
    
    # Generate stability plan (simplified logic)
    verification_score = 23  # Would be calculated from telemetry
    
    triggers = [
        "Sudden spikes in concurrency triggered automated risk flags",
        "Retry storms after 429s made traffic look adversarial",
        "Long tool loops without cooldowns raised abuse heuristics",
        "Sustained peak throughput without pacing windows",
    ]
    
    guardrails = [
        Guardrail("cap_concurrency", "Cap concurrency during peak hours", enabled=True),
        Guardrail("jitter_backoff", "Jitter + backoff on retries", enabled=True),
        Guardrail("tool_loop_limiter", "Tool loop limiter (stop after N cycles)", enabled=True),
        Guardrail("cache_dedupe", "Cache / dedupe repeated requests", enabled=False),
    ]
    
    # Interactive guardrail selection
    console.print("\n[bold]What likely triggered this:[/bold]")
    for trigger in triggers:
        console.print(f"  ‚Ä¢ {trigger}")
    
    console.print("\n[bold]Good Citizen Guardrails:[/bold]")
    for i, g in enumerate(guardrails):
        status = "[green]‚úì[/green]" if g.enabled else "[dim]‚óã[/dim]"
        console.print(f"  {status} {g.description}")
    
    console.print("\n[dim]Toggle guardrails? (Enter numbers separated by commas, or press Enter to continue)[/dim]")
    toggle_input = Prompt.ask("Toggle", default="")
    
    if toggle_input.strip():
        try:
            indices = [int(x.strip()) - 1 for x in toggle_input.split(",")]
            for idx in indices:
                if 0 <= idx < len(guardrails):
                    guardrails[idx].enabled = not guardrails[idx].enabled
        except ValueError:
            pass
    
    # Create stability plan
    stability_plan = StabilityPlan(
        verification_score=verification_score,
        triggers=triggers,
        guardrails=guardrails,
        intake=intake,
    )
    
    # Save locally
    filepath = save_data("plan.json", stability_plan.to_dict())
    
    # Submit to API
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task("Submitting plan...", total=None)
        result = api.submit_plan(stability_plan)
    
    if output_json:
        console.print(json.dumps({"plan": stability_plan.to_dict(), "result": result}, indent=2))
    else:
        console.print(f"\n[green]‚úì[/green] Plan saved to {filepath}")
        console.print(f"[green]‚úì[/green] Plan ID: {result.get('plan_id')}")
        console.print(f"[yellow]![/yellow] Verification score: {verification_score} (Unverified)")
        console.print("\n[dim]Next: Run [bold]swimmeret pool[/bold] to join the builder pool.[/dim]")


@app.command()
def pool(
    plan_file: Optional[Path] = typer.Option(None, "--plan-file", "-p", help="Path to plan JSON"),
    output_json: bool = typer.Option(False, "--json", help="Output as JSON"),
) -> None:
    """
    Join the builder pool with a pledge.
    
    Aggregate your purchasing power with other builders to negotiate
    better terms with LLM providers.
    """
    # Load plan data
    if plan_file:
        plan_data = json.loads(plan_file.read_text())
    else:
        plan_data = load_data("plan.json")
    
    if not plan_data:
        console.print("[red]No plan data found. Run 'swimmeret plan' first.[/red]")
        raise typer.Exit(1)
    
    # Reconstruct plan
    intake = IntakeData(**plan_data["intake"])
    guardrails = [Guardrail(**g) for g in plan_data["guardrails"]]
    stability_plan = StabilityPlan(
        verification_score=plan_data["verification_score"],
        triggers=plan_data["triggers"],
        guardrails=guardrails,
        intake=intake,
        timestamp=plan_data["timestamp"],
    )
    
    console.print(Panel.fit(
        "[bold blue]Swimmeret Builder Pool[/bold blue]\n"
        "Join the collective for better terms",
        border_style="blue",
    ))
    
    # Show pool status
    pool_status = api.get_pool_status()
    console.print(f"\n[bold]Heavy Agent Builders - Stable Lane[/bold]")
    console.print(f"  {pool_status['pledged_seats']}/{pool_status['target_seats']} seats pledged")
    console.print(f"  50 seats ‚Üí baseline terms + $/seat target")
    console.print(f"  100 seats ‚Üí priority lane + better terms")
    
    console.print("\n[bold]Terms to unlock:[/bold]")
    terms = [
        "Throughput floor with priority lane during peak",
        "Policy notice window before enforcement changes",
        "Clear acceptable-use envelope for automation",
        "Dedicated escalation path for verified builders",
    ]
    for term in terms:
        console.print(f"  ‚Ä¢ {term}")
    
    # Collect pledge
    console.print("\n[bold]Your Pledge[/bold]")
    seats_intended = IntPrompt.ask("Seats intended", default=intake.paid_seats)
    willingness = prompt_enum("Willingness to pay", WillingnessToPay)
    email = Prompt.ask("Email or handle")
    referral = Prompt.ask("Referral code (optional)", default="")
    
    console.print("\n[dim]By confirming, you indicate intent to purchase if terms are met.[/dim]")
    confirmed = Confirm.ask("I intend to purchase if terms are met", default=True)
    
    if not confirmed:
        console.print("[yellow]Pledge not confirmed. You can run this again when ready.[/yellow]")
        raise typer.Exit(0)
    
    # Create pledge
    pledge = PoolPledge(
        seats_intended=seats_intended,
        willingness_to_pay=willingness,
        email_or_handle=email,
        referral_code=referral if referral else None,
        intent_confirmed=confirmed,
        plan=stability_plan,
    )
    
    # Save locally
    filepath = save_data("pledge.json", pledge.to_dict())
    
    # Submit to API
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task("Submitting pledge...", total=None)
        result = api.submit_pledge(pledge)
    
    if output_json:
        console.print(json.dumps({"pledge": pledge.to_dict(), "result": result}, indent=2))
    else:
        console.print(f"\n[green]‚úì[/green] Pledge saved to {filepath}")
        console.print(f"[green]‚úì[/green] Pledge ID: {result.get('pledge_id')}")
        console.print(f"\n[bold]Your referral code:[/bold] {result.get('referral_code')}")
        console.print(f"[bold]Share link:[/bold] {result.get('pool_url')}")
        console.print("\n[green]Welcome to the pool! üèä[/green]")


@app.command()
def status(
    output_json: bool = typer.Option(False, "--json", help="Output as JSON"),
) -> None:
    """
    Check current pool status.
    
    Shows pledged seats, verified builders, and progress toward
    unlocking better terms.
    """
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task("Fetching pool status...", total=None)
        pool_status = api.get_pool_status()
    
    if output_json:
        console.print(json.dumps(pool_status, indent=2))
        return
    
    console.print(Panel.fit(
        "[bold cyan]Swimmeret Builder Pool[/bold cyan]\n"
        "Verified demand for a stable lane",
        border_style="cyan",
    ))
    
    # Progress bar
    progress_pct = pool_status["pledged_seats"] / pool_status["target_seats"]
    bar_width = 40
    filled = int(bar_width * progress_pct)
    bar = "‚ñà" * filled + "‚ñë" * (bar_width - filled)
    
    console.print(f"\n[bold]{pool_status['name']}[/bold]")
    console.print(f"  [{bar}] {pool_status['pledged_seats']}/{pool_status['target_seats']}")
    
    # Stats table
    table = Table(show_header=False, box=None)
    table.add_column("Metric", style="dim")
    table.add_column("Value", style="bold")
    table.add_row("Pledged seats", str(pool_status["pledged_seats"]))
    table.add_row("Verified seats", str(pool_status["verified_seats"]))
    table.add_row("Builders", str(pool_status["builders"]))
    console.print(table)
    
    # Urgency mix
    urgency = pool_status["urgency_mix"]
    console.print(f"\n[dim]Urgency: Today: {urgency['today']} | This week: {urgency['this_week']} | This month: {urgency['this_month']}[/dim]")


@app.command()
def wizard() -> None:
    """
    Full guided flow: intake ‚Üí plan ‚Üí pool.
    
    Walks you through the entire process of reporting your throttling
    incident, generating a stability plan, and joining the builder pool.
    """
    console.print(Panel.fit(
        "[bold magenta]Swimmeret Wizard[/bold magenta]\n"
        "Throttle shock to builder pool in under 60 seconds",
        border_style="magenta",
    ))
    
    console.print("\n[bold]Step 1/3: Intake[/bold]")
    console.print("[dim]Report your throttling incident[/dim]\n")
    intake()
    
    console.print("\n" + "‚îÄ" * 50 + "\n")
    
    console.print("[bold]Step 2/3: Stability Plan[/bold]")
    console.print("[dim]Generate your good citizen guardrails[/dim]\n")
    plan()
    
    console.print("\n" + "‚îÄ" * 50 + "\n")
    
    console.print("[bold]Step 3/3: Join Pool[/bold]")
    console.print("[dim]Pledge your seats to aggregate demand[/dim]\n")
    pool()
    
    console.print("\n" + "‚ïê" * 50)
    console.print("[bold green]üéâ Complete! You're now part of the Swimmeret pool.[/bold green]")


if __name__ == "__main__":
    app()
